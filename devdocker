#! /usr/bin/python

# @devdocker is a utility meant to "manage" a docker container that
# encapsulates the build environment for a project. In addition, it can be
# used to build docker images with the project's build environment.
# Devdocker supports the following commands -

# devdocker create
#   Creates a docker container that encapsulates the build environment for
#   the project. The gitroot is mounted inside this container at the same
#   path. Additional directories can be mounted inside the container by
#   specifying them in the devdocker config file. Commands provided as
#   @postCreateCmds in the ".devdockercfg" are executed with gitroot as the
#   working directory.

# devdocker exec [ARG [ARGS...]]
#   Runs the supplied command inside the "devdocker" container. Current
#   directory is setup to be the working directory for these commands.
#   For example: $ devdocker exec ls -l

# devdocker shell
#   Starts an interactive shell inside the said container with the src
#   directory as the current working directory. By default, the shell can
#   have messed up column width. One workaround is to resize the terminal
#   window which seems to fix the issue.

# devdocker mkimg
#   Builds the docker image required for the dev container. In addition,
#   the images are tagged with version numbers taken from the devdocker
#   config file. Finally, it also prints a set of commands that can be used
#   to publish this image to the docker registry. We do not include the
#   publish functionality as part of the devdocker tool itself since that
#   requires access to docker login credentials etc.
#
# devdocker portfwd
#   Helps users forward ports from inside docker containers to the host.
#   Usage: devdocker portfwd <container port> [<host port>]
#
# @devdocker accepts configuration via file named ".devdockercfg". This
# file should be placed at the gitroot of the project. The contents of
# the config file is python code snippet file that evaluates to python
# dictionary. ".devdockercfg" can have the following fields -
#
#   - registry, imageName, imageVersion: Image created by mkimg command is
#     tagged with registry/imageName:imageVersion.
#   - containerName:
#   - dockerFile:
#   - mount: List of files to be mounted inside the devdocker container.
#     Each entry of the list must be of form 'host/path:container/path'.
#   - ports: List of ports to be exported from the container. Each entry of
#     list must be of the form 'host_ip:host_port:container_port/protocol'.
#   - environment: Dictionary of environment variables initialized inside
#     container.
#   - postCreateCmds: Each command in this list is executed inside the
#     container after its creation.
#
# Paths in .devdockercfg can refer to users home directory and source
# directory of a project using %(HOMEDIR)s and %(SRCDIR)s respectively.

import argparse
import datetime
import os
import pipes
import uuid
import shutil
import socket
import subprocess
import sys
import tempfile
import time

kCfgFileName = '.devdockercfg'
kMyCfgFileName = '.mydevdockercfg'

class MissingConfigFileError(Exception):
  def __init__(self):
    pass

def findCfgFile():
  currDir = os.path.abspath(os.getcwd())
  while not os.path.exists(os.path.join(currDir, kCfgFileName)):
    if currDir == '/':
      raise MissingConfigFileError()
    currDir = os.path.dirname(currDir)
  return os.path.join(currDir, kCfgFileName)

def findMyCfgFile():
  return os.path.join(os.path.dirname(findCfgFile()), kMyCfgFileName)

def readDict(fileName):
  class Object:
    pass
  obj = Object()
  with open(fileName) as f:
    obj.__dict__.update(eval(f.read()))
  return obj

def readConfig():
  cfg = readDict(findCfgFile())
  cfg.imageTag = '%s/%s:%s' % (
      cfg.registry, cfg.imageName, cfg.imageVersion)
  return cfg

# A simple wrapper around subprocess.Popen with proper handling for Ctrl-C.
# Ctrl-C events are routed to the underlying subprocess.
def popenWrapper(argv):
  try:
    pid = subprocess.Popen(argv)
    pid.wait()
  except KeyboardInterrupt:
    print "WARNING: Ctrl-C does not kill the underlying process. The \n" +\
          "process is (most likely) still running inside the container"
    pid.kill()
  return pid.returncode

def createFn(args, unknownArgs):
  cfg = readConfig()
  homedir = os.path.expanduser('~')
  srcdir = os.getcwd()
  substitutions = {
    'SRCDIR': srcdir,
    'HOMEDIR': homedir,
  }
  tmpdir = "/tmp/devdocker.local"
  shutil.rmtree(tmpdir, ignore_errors=True)
  os.mkdir(tmpdir, 0o755)
  try:
    with open(tmpdir + '/Dockerfile', 'w') as localDockerFile:
      localDockerFile.write("""
ARG BASE_IMAGE
FROM ${BASE_IMAGE}

ARG UID
ARG HOMEDIR
ARG SRCDIR
RUN mkdir -p $(dirname $HOMEDIR)
RUN useradd -u $UID -m -d $HOMEDIR devdocker
RUN echo "devdocker ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers
USER devdocker
WORKDIR $SRCDIR
RUN mkdir -p $SRCDIR
      """)
      myCfgFile = findMyCfgFile()
      if os.path.exists(myCfgFile):
        myCfg = readDict(myCfgFile)
        for e in myCfg.files:
          localDockerFile.write(
            'COPY %s %s\n' % (
                e['src'] % substitutions,
                e['dst'] % substitutions
          ))
    devnull = open(os.devnull, 'w')
    imgDigest = subprocess.check_output(
        ['docker', 'image', 'build', '-q',
         '--build-arg', 'BASE_IMAGE=%s' % cfg.imageTag,
         '--build-arg', 'UID=%d' % os.getuid(),
         '--build-arg', 'HOMEDIR=%s' % homedir,
         '--build-arg', 'SRCDIR=%s' % srcdir, tmpdir]).strip()
    envFlags = [
      '-e', 'DEVDOCKER_HOST=%s' % socket.gethostbyname(
          socket.gethostname())
    ]
    if 'environment' in dir(cfg):
      for var, value in cfg.environment.items():
        envFlags.extend(['-e', '%s=%s' % (var, value % substitutions)])
    mountFlags = [ '-v', '%s:%s' % (srcdir, srcdir) ]
    if 'mount' in dir(cfg):
      for m in cfg.mount:
        mountFlags.extend(['-v', m % substitutions])
    portFlags = []
    if 'ports' in dir(cfg):
      for p in cfg.ports:
        portFlags.extend(['-p', p])
    # Delete any existing container with the provided containerName
    subprocess.call(
        ['docker', 'rm', '-f', cfg.containerName],
        stdout = devnull, stderr = devnull)
    subprocess.check_call(
        ['docker', 'run', '-d', '-i', '-t' ] +
        envFlags +
        mountFlags +
        portFlags +
        ['--name=%s' % cfg.containerName, '--privileged', imgDigest])
    # Run any post-create commands after container creation.
    if 'postCreateCmds' in dir(cfg):
      for cmd in cfg.postCreateCmds:
        cmd = map(lambda x: x % substitutions, cmd)
        popenWrapper(
          ['docker', 'exec', cfg.containerName] + cmd)
  finally:
    shutil.rmtree(tmpdir)

def execFn(args, unknownArgs):
  cfg = readConfig()
  # We setup devdocker containers such that absolute paths outside the
  # container also work inside the container.
  workingDir = os.path.abspath(args.cwd)
  if args.interactive:
    # We inject a super-hacky sleep statement because for some weird
    # reason the terminal behavior (number of columns etc) are properly
    # setup in the presence of that sleep statement.
    joinedArgs = ' '.join(map(lambda x : pipes.quote(x), unknownArgs))
    sys.exit(popenWrapper(
        ['docker', 'exec', '-it', '-w', workingDir, cfg.containerName] + \
        ['bash', '-c', 'sleep 0.05 && %s' % joinedArgs]))
  else:
    cmd = ['docker', 'exec', '-w', workingDir]
    if not sys.stdin.isatty():
      cmd += ['-i']
    cmd += [cfg.containerName] + unknownArgs
    sys.exit(popenWrapper(cmd))

def shellFn(args, unknownArgs):
  cfg = readConfig()
  workingDir = os.path.abspath(os.getcwd())
  subprocess.call(
      ['docker', 'exec', '-it', '-w', workingDir,
       cfg.containerName, '/bin/bash'])

def mkImgFn(args, unknownArgs):
  cfg = readConfig()
  subprocess.check_call(
      ['docker', 'image', 'build',
       '-f', cfg.dockerFile, os.path.dirname(cfg.dockerFile)])
  # We issue the same build again with -q to get imageDigest. Because of
  # docker caching this command will execute quite quickly.
  imgDigest = subprocess.check_output(
      ['docker', 'image', 'build', '-q',
       '-f', cfg.dockerFile, os.path.dirname(cfg.dockerFile)]).strip()
  newImageTag = '%s/%s:%s' % (
      cfg.registry,
      cfg.imageName,
      datetime.datetime.now().strftime("%Y-%m-%d") + "-" + imgDigest[7:19])
  subprocess.check_call(
      ['docker', 'tag', imgDigest, newImageTag])
  print '\n\nSuccessfully created image: %s' % newImageTag
  print 'Login to the docker registry and publish image using the'
  print 'following command: '
  print '  $ docker push ' + newImageTag
  print 'Update `imageVersion` in .devdockercfg to ' + newImageTag

def portfwdFn(args, unknownArgs):
  try:
    cfg = readConfig()
    ip = subprocess.check_output([
        'docker', 'inspect', cfg.containerName, '--format',
        '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}'])
    hostPort = args.containerPort if args.hostPort == 0 else args.hostPort
    subprocess.check_call([
        'docker', 'run', '--rm', '-p', '%d:1234' % hostPort, 'verb/socat',
        'TCP-LISTEN:1234,fork',
        'TCP-CONNECT:%s:%d' % (ip, args.containerPort)])
  except KeyboardInterrupt:
    pass

def ArgParser():
  parser = argparse.ArgumentParser(
    prog = 'devdocker',
    description = 'Utility for creating/managing the dev container')
  subparsers = parser.add_subparsers(
    title = 'subcommands',
    help = 'execute commands with -h for further help')

  # create command
  createP = subparsers.add_parser(
      'create',
      description = 'Create the dev container',
      help = 'Create the dev container')
  createP.set_defaults(func = createFn)

  # exec command
  execP = subparsers.add_parser(
      'exec',
      description = 'Execute a command inside the dev container',
      help = 'Execute a command inside the dev container')
  execP.add_argument(
    '-i', '--interactive', dest = 'interactive', action = 'store_true',
    help = 'Execute interactive commands like gdb etc.')
  execP.set_defaults(interactive = False)
  execP.add_argument(
    '--cwd', dest = 'cwd', action = 'store',
    help = 'Set working directory for provided command.')
  execP.set_defaults(cwd = '.')
  execP.set_defaults(func = execFn)

  # shell command
  shellP = subparsers.add_parser(
      'shell',
      description = 'Start an interactive shell within the dev container',
      help = 'Start an interactive shell within the dev container')
  shellP.set_defaults(func = shellFn)

  # mkimg command
  mkimgP = subparsers.add_parser(
      'mkimg',
      description = 'Builds the docker image for the dev container',
      help = 'Builds the docker image for the dev container')
  mkimgP.set_defaults(func = mkImgFn)

  portfwdP = subparsers.add_parser(
      'portfwd',
      description = 'Forwards the port from container to host',
      help = 'Builds the docker image for the dev container')
  portfwdP.add_argument(
      'containerPort', type = int, metavar = 'container-port',
      help = 'The container port to forward')
  portfwdP.add_argument(
      'hostPort', type = int, metavar = 'host-port',
      help = 'The host port to forward', nargs = '?', default = 0)
  portfwdP.set_defaults(func = portfwdFn)

  return parser

def main(argv):
  # Sometimes the commandline being executed with devdocker exec can
  # have arguments that conflict with the command line parsing of the
  # devdocker script itself. For example, if the exec command has its own
  # --help argument, that can be interpreted as the --help argument of the
  # devdocker command. In such situations, we can separate the two command
  # lines by providing a -- escape marker. For example, the following
  # command will not print the gcc help message as intended.
  #   $ devdocker exec gcc --help
  # However, after adding a -- escape marker, we will get the expected
  # help message.
  #   $ devdocker exec -- gcc --help
  escapeMarker = -1
  try:
    escapeMarker = argv.index('--')
  except:
    pass
  escapedArgs = []
  if escapeMarker >= 0:
    escapedArgs = argv[escapeMarker + 1:]
    argv = argv[:escapeMarker]
  parser = ArgParser()
  args, unknownArgs = parser.parse_known_args(args = argv)
  args.func(args, unknownArgs + escapedArgs)

if __name__ == '__main__':
  try:
    main(sys.argv[1:])
  except MissingConfigFileError:
    sys.stderr.write('.devdockercfg not found in any parent directory\n')
    sys.exit(1)
